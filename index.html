<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0"/>
  <title>‚ö° 4HM Jank-O-Meter ‚Äî Percentile Scoring (Final)</title>

  <!-- libs -->
  <script src="https://code.jquery.com/jquery-3.6.0.min.js" crossorigin="anonymous"></script>
  <script src="https://cdn.jsdelivr.net/npm/papaparse@5.4.1/papaparse.min.js"></script>
  <link rel="stylesheet" href="https://cdn.datatables.net/1.13.6/css/jquery.dataTables.min.css" />
  <script src="https://cdn.datatables.net/1.13.6/js/jquery.dataTables.min.js"></script>

  <style>
    :root{
      --bg:#fdf6e3; --ink:#2b1a08; --panel:#f9f2dd; --line:#c8a96c; --thead:#f2e6c6; --muted:#5a3816;
    }
    body{font-family:"Book Antiqua", Palatino, serif;background:var(--bg);color:var(--ink);}
    header{text-align:center;padding:10px}
    .sub{opacity:.8}
    .wrap{max-width:1100px;margin:0 auto}
    .panel{background:var(--panel);border:2px solid var(--line);border-radius:16px;padding:14px;margin:12px auto}
    .score-badge{background:var(--thead);border:1px solid var(--line);padding:10px;border-radius:12px;margin:6px 0}
    .muted{opacity:.8}
    .tag{display:inline-block;padding:2px 6px;border-radius:999px;border:1px solid var(--line);background:#fff9e6;margin-left:6px;font-size:12px;color:var(--muted)}
    .tag.banned{border-color:#b66;background:#fde9e9;color:#8b1a1a}
    .tag.restricted{border-color:#b88;background:#fbeff8;color:#8b4513}
    textarea#deckInput{width:100%;min-height:150px;border:1px solid var(--line);border-radius:8px;padding:8px;background:#fffaf0}
    button, .btn{background:#e8d8ad;border:1px solid var(--line);border-radius:10px;padding:8px 12px;cursor:pointer}
    table.dataTable{background:var(--bg);border:2px solid #d6b87a;border-radius:12px}
    table.dataTable thead th{background:var(--thead);color:#3a240a;font-weight:bold}
    .flex{display:flex;gap:8px;align-items:center;flex-wrap:wrap}
    .right{float:right}
  </style>
</head>
<body>
  <header>
    <h1>‚ö° 4HM Jank-O-Meter ‚ö°</h1>
    <div class="sub">Percentile scoring + land-inclusive denominator + debug readout</div>
  </header>

  <div class="wrap">
    <div class="panel" id="scorePanel">
      <h2>üß™ Jank Score + ‚úÖ Deck Validator</h2>
      <textarea id="deckInput" placeholder="Paste your decklist here...\nUse a line that starts with 'Sideboard' to switch sections."></textarea>
      <div class="flex">
        <input type="file" id="deckFile" accept=".txt,.dek,.dec"/>
        <button id="analyzeBtn">Analyze &amp; Validate Deck</button>
        <label class="flex"><input type="checkbox" id="includeSb"/> Include sideboard in scores</label>
        <button id="exportCsvBtn" class="right">Export CSV</button>
      </div>
      <div class="score-badge">
        <b>Jank Score:</b> <span id="scoreValue">‚Äî</span>/100
        <div id="scoreFlavor" class="muted"></div>
        <div id="jankDebug" style="margin-top:6px;font-size:12px;opacity:.9"></div>
      </div>
      <div class="score-badge">
        <b>Top 10 Jankiest</b>
        <ol id="topJank"></ol>
      </div>
      <div class="score-badge">
        <b>Badges</b>
        <div id="badgeBlock" class="muted"></div>
      </div>
      <div class="score-badge">
        <b>Validation</b>
        <div id="valStatus"></div>
        <ul id="valErrors"></ul>
      </div>
    </div>

    <div class="panel">
      <div class="table-wrap">
        <table id="jankTable" class="display" style="width:100%">
          <thead>
            <tr>
              <th>Set</th>
              <th>Card</th>
              <th>Main Deck</th>
              <th>Sideboard</th>
              <th>Total</th>
              <th>Jank Pts (per copy)</th>
            </tr>
          </thead>
          <tbody></tbody>
        </table>
      </div>
      <div class="muted" id="lastUpdated">‚è±Ô∏è <b>Last updated:</b> ‚Äî</div>
    </div>
  </div>

<script>
// === CONFIG ===
// Use your real published CSVs here (left as examples from prior versions):
const CARDPOOL_URL = "https://docs.google.com/spreadsheets/d/e/2PACX-1vTbTvT5tNT1w_Nqz1dL-t3muSuqzQ8UkO9ssHNZT1koEM8iVQQuY7QwGpTImtqv58zT837gLm8GZG84/pub?output=csv"; // 4HM totals
const BR_URL       = "https://docs.google.com/spreadsheets/d/e/2PACX-1vQP2NPEcvsNl4wkBSKApw-opRIZ-C3rwFj51wJbMh1wYm_ci8y7o46gyfSubTbsfApvpoJpS2ysRohD/pub?output=csv"; // Ban/Restrict

// === GLOBAL STATE ===
let allRows = [];           // cardpool rows (set, card, total, etc.)
let dataTable = null;
let MAX_TOTAL = 1;          // diagnostic only
let lastCsvDate = new Date().toLocaleString();

let BANNED = new Set();
let RESTRICTED = new Set();

const BASIC_SET = new Set(["plains","island","swamp","mountain","forest"]);
const DUAL_SET = new Set(["badlands","bayou","plateau","savannah","scrubland","taiga","tropicalisland","tundra","undergroundsea","volcanicisland"]);

function normName(s){ return String(s||'').toLowerCase().replace(/[^a-z0-9]/g,''); }
function isDual(key){ return DUAL_SET.has(key); }
function isStaple(total){ return Number(total) >= 350; }

// === Percentile distribution ===
let ELIGIBLE_SORTED = []; // sorted ascending eligible totals
let JANK_PERC_GAMMA = 0.85; // curve sharpness: higher => harsher on common

function prepareEligibleDistribution(rows){
  const totals = rows
    .filter(r => !(BASIC_SET.has(r.key) || isDual(r.key)) && !isStaple(r.total))
    .map(r => Number(r.total)||0)
    .sort((a,b)=>a-b);
  ELIGIBLE_SORTED = totals;
}

function percentileOfTotal(t){
  if (!ELIGIBLE_SORTED.length) return 1;
  t = Number(t)||0;
  let lo = 0, hi = ELIGIBLE_SORTED.length;
  while (lo < hi){
    const mid = (lo + hi) >> 1;
    if (ELIGIBLE_SORTED[mid] <= t) lo = mid + 1; else hi = mid;
  }
  return lo / ELIGIBLE_SORTED.length; // 0=rarest .. 1=common
}

function jankWeight(t, key){
  if (BASIC_SET.has(key) || isDual(key) || isStaple(t)) return 0;
  const p = percentileOfTotal(t);
  return Math.round(100 * Math.pow(1 - p, JANK_PERC_GAMMA));
}

// === Deck parsing ===
function parseDeck(text){
  const lines = text.split(/\r?\n/);
  const main = new Map(); const side = new Map();
  let toSide=false;
  for (const raw of lines){
    const line=raw.trim(); if(!line) continue;
    if(/^side/i.test(line)){ toSide=true; continue; }
    const m=line.match(/^(\d+)?\s*(.+)$/);
    if(!m) continue;
    const n=m[1]?parseInt(m[1],10):1;
    const key=normName(m[2]);
    (toSide?side:main).set(key,(toSide?side:main).get(key)||0+n);
  }
  return {main, side};
}

// === Scoring ===
function scoreDeck(parsed, includeSide){
  // Map keys to rows
  const map = new Map(); const nameMap = new Map();
  for(const r of allRows){ const k = normName(r.card); if(!map.has(k)) map.set(k,r); if(!nameMap.has(k)) nameMap.set(k, r.card); }

  function mapToArr(m){ return Array.from(m.entries()).map(([key,count])=>({key, count})); }
  const mainArr = mapToArr(parsed.main); const sideArr = mapToArr(parsed.side);

  const matchedMain = []; const matchedSide = []; const unmatched = [];
  for(const item of mainArr){ const row = map.get(item.key); if(!row){ unmatched.push(`Main: ${item.count} √ó ${item.key}`); continue; } matchedMain.push({ key:item.key, official: nameMap.get(item.key)||item.key, total: Number(row.total)||0, count: item.count }); }
  for(const item of sideArr){ const row = map.get(item.key); if(!row){ unmatched.push(`Side: ${item.count} √ó ${item.key}`); continue; } matchedSide.push({ key:item.key, official: nameMap.get(item.key)||item.key, total: Number(row.total)||0, count: item.count }); }

  // Numerator (percentile jankWeight)
  let raw = 0; let copiesMain = 0;
  for(const m of matchedMain){ raw += m.count * jankWeight(m.total, m.key); copiesMain += m.count; }
  if(includeSide){ for(const s of matchedSide){ raw += s.count * jankWeight(s.total, s.key); } }

  // Denominator: ALL cards (lands included), main + SB if checked
  const totalMain = matchedMain.reduce((a,b)=> a + b.count, 0);
  const totalSide = includeSide ? matchedSide.reduce((a,b)=> a + b.count, 0) : 0;
  const rawMax = (totalMain + totalSide) * 100 || 1;

  // Base score
  const baseScore = Math.max(0, Math.min(100, (raw / rawMax) * 100));

  // Density bonus over ELIGIBLE MAIN (not all 60); cap 40
  const eligibleMain = matchedMain.filter(x => !(BASIC_SET.has(x.key) || isDual(x.key)) && !isStaple(x.total));
  const eligibleMainCopies = eligibleMain.reduce((a,b)=> a + b.count, 0);
  const deepMainCopies = eligibleMain.filter(x => x.total <= 20).reduce((a,b)=> a + b.count, 0);
  const deepDensity = eligibleMainCopies ? Math.round(100 * deepMainCopies / eligibleMainCopies) : 0;
  const BONUS_CAP = 40; const BONUS_EXP = 1.1;
  const bonus = Math.round(BONUS_CAP * Math.pow(deepDensity / 100, BONUS_EXP));

  // Over-60 bonus (unchanged)
  const over60 = Math.max(0, copiesMain - 60);
  const over60Bonus = over60 * 0.25;

  const finalScore = Math.max(0, Math.min(100, baseScore + bonus + over60Bonus));

  // Top 10 (per-copy jank)
  const allForTop = [...matchedMain].map(x => ({ key:x.key, name:x.official, w: jankWeight(x.total,x.key), total:x.total, count:x.count }));
  allForTop.sort((a,b)=> b.w - a.w);
  const top10 = allForTop.slice(0,10);

  // Badges (simple counts by rarity buckets for UI flavor only)
  const buckets = { ultra:0, deep:0, med:0, light:0, ultralight:0 };
  for (const m of matchedMain){
    if (BASIC_SET.has(m.key) || isDual(m.key) || isStaple(m.total)) continue;
    const t = m.total;
    if (t <= 1) buckets.ultra += m.count;
    else if (t <= 4) buckets.deep += m.count;
    else if (t <= 10) buckets.med += m.count;
    else if (t <= 20) buckets.light += m.count;
    else if (t <= 25) buckets.ultralight += m.count;
  }

  // Debug readout
  const sumMain = matchedMain.reduce((a,m)=> a + m.count * jankWeight(m.total, m.key), 0);
  const sumSB   = matchedSide.reduce((a,s)=> a + s.count * jankWeight(s.total, s.key), 0);
  const copiesSBAll = matchedSide.reduce((a,b)=> a + b.count, 0);
  const avgMain = copiesMain ? (sumMain / copiesMain / 100).toFixed(2) : "0.00";
  const avgSB   = copiesSBAll ? (sumSB   / copiesSBAll / 100).toFixed(2) : "0.00";
  const denomCopies = totalMain + (includeSide ? totalSide : 0);

  const dbg = document.getElementById('jankDebug');
  if (dbg){
    dbg.textContent = `Main avg jank/copy: ${avgMain}` + (includeSide ? `  ‚Ä¢  SB avg: ${avgSB}` : ``) + `  ‚Ä¢  Denominator copies: ${denomCopies}  ‚Ä¢  Eligible deep density: ${deepDensity}% (cap ${BONUS_CAP})`;
  }

  return { score: Math.round(finalScore), baseScore: Math.round(baseScore), bonus, deepDensity, top10, copiesMain, over60, over60Bonus, buckets };
}

// === Table render & CSV ===
function renderTable(threshold=1000, setFilter=""){
  const rows = allRows.filter(r => r.total <= threshold && (!setFilter || r.set === setFilter));
  rows.forEach(r => { r.jankValue = jankWeight(r.total,r.key)===0 ? 0 : Number((jankWeight(r.total,r.key)/60).toFixed(2)); });
  const data = rows.map(r => {
    const isBan = BANNED.has(r.key);
    const isRes = RESTRICTED.has(r.key);
    const tags = `${isBan?'<span class="tag banned">BANNED</span>':''}${(!isBan && isRes)?'<span class="tag restricted">Restricted</span>':''}`;
    const link = `<a href="#" class="cardlink" data-key="${r.key}">${r.card}</a>${tags}`;
    return [r.set, link, r.main||0, r.side||0, r.total||0, r.jankValue===0?"0":r.jankValue];
  });
  if(dataTable){ dataTable.clear().rows.add(data).order([[4,'desc'],[0,'asc'],[1,'asc']]).draw(); bindRowClicks(); }
  else {
    dataTable = jQuery('#jankTable').DataTable({ data, columns: [ { title: 'Set' }, { title: 'Card' }, { title: 'Main Deck' }, { title: 'Sideboard' }, { title: 'Total' }, { title: 'Jank Pts (per copy)' } ], order: [[4, 'desc'], [0, 'asc'], [1, 'asc']], pageLength: 25, deferRender: true, dom: 'tip' });
    bindRowClicks();
  }
}

function exportCSV(){
  const rows = allRows;
  const header = ['Set','Card','Main Deck','Sideboard','Total','Jank Pts (per copy)'];
  const lines = [header.join(',')].concat(rows.map(r => [r.set, r.card, r.main||0, r.side||0, r.total||0, jankWeight(r.total,r.key)===0?"0":(jankWeight(r.total,r.key)/60).toFixed(2)].join(',')));
  const blob = new Blob([lines.join('\n')], {type:'text/csv;charset=utf-8;'});
  const a = document.createElement('a'); a.href = URL.createObjectURL(blob);
  a.download = `4HM-jank-export.csv`; a.click();
}

// === UI wiring ===
function flavorFor(score, bonus){
  let msg;
  if (score >= 90) msg = 'üß™ Maximum spice achieved ‚Äî expect the unexpected.';
  else if (score >= 70) msg = 'üåã The Jank is STRONG with this one.';
  else if (score >= 50) msg = 'üå∂Ô∏è Solidly spicy ‚Äî a connoisseur‚Äôs brew.';
  else if (score >= 25) msg = 'üßØ Respectable heat with room to get weird.';
  else msg = 'üõ°Ô∏è More staple than spice. Dare to jank harder?';
  if (bonus >= 15) msg += ' üß™ Dense spice pocket detected.';
  return msg;
}

function bindRowClicks(){
  // Placeholder for card modal hooks if you want to wire Scryfall, etc.
}

function analyze(){
  const txt = document.getElementById('deckInput').value || '';
  if(!txt.trim()){ alert('Paste a decklist first.'); return; }
  const parsed = parseDeck(txt);
  const includeSb = document.getElementById('includeSb').checked;
  const r = scoreDeck(parsed, includeSb);
  document.getElementById('scoreValue').textContent = r.score;
  document.getElementById('scoreFlavor').textContent = flavorFor(r.score, r.bonus);
  const list = document.getElementById('topJank'); list.innerHTML='';
  r.top10.forEach((t,i)=>{ const li=document.createElement('li'); li.innerHTML = `${i+1}. ${t.name} (${(t.w/60).toFixed(2)} pts/copy)`; list.appendChild(li); });
  const b = r.buckets;
  document.getElementById('badgeBlock').innerHTML = `
    üîµ Ultra-jank (‚â§1 Total): ${b.ultra} &nbsp; 
    üü£ Deep-jank (‚â§4 Total): ${b.deep} &nbsp;
    üü† Medium-jank (‚â§10 Total): ${b.med} &nbsp;
    üî• Light-jank (‚â§20 Total): ${b.light} &nbsp;
    üü° Ultralight-jank (‚â§25 Total): ${b.ultralight}`;
}

document.getElementById('analyzeBtn').addEventListener('click', analyze);

document.getElementById('deckFile').addEventListener('change', e => {
  const f = e.target.files[0]; if(!f) return;
  f.text().then(t => { document.getElementById('deckInput').value = t; });
});

document.getElementById('includeSb').addEventListener('change', analyze);

document.getElementById('exportCsvBtn').addEventListener('click', exportCSV);

// === Ingest CSVs ===
function ingestPool(rows){
  allRows = rows.map(r=>({
    set: r.set || r.Set || '',
    card: r.card || r.Card || r.name || '',
    main: Number(r.main||r.Main||0),
    side: Number(r.side||r.Side||0),
    total: Number(r.total||r.Total||0),
    key: normName(r.card || r.Card || r.name || '')
  }));
}

function ingestBR(rows){
  rows.forEach(r=>{ const key = normName(r.card||r.Card||''); const s = (r.status||'').toUpperCase(); if(s==='BANNED') BANNED.add(key); if(s==='RESTRICTED') RESTRICTED.add(key); });
}

function initUI(){
  MAX_TOTAL = Math.max(1, ...allRows.map(r=>Number(r.total)||0));
  prepareEligibleDistribution(allRows);
  renderTable();
  document.getElementById('lastUpdated').innerHTML = `‚è±Ô∏è <b>Last updated:</b> ${lastCsvDate}`;
}

// Load pool & BR
Papa.parse(CARDPOOL_URL, { download:true, header:true, complete: res => { ingestPool(res.data); lastCsvDate = new Date().toLocaleString(); Papa.parse(BR_URL, { download:true, header:true, complete: br => { ingestBR(br.data); initUI(); } }); } });
</script>
</body>
</html>
