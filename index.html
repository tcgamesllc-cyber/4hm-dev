<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0"/>
  <title>⚡ 4HM Jank‑O‑Meter — Neutralized Staples (v18 patch) ⚡</title>
  <meta name="robots" content="noindex">
  <style>
    :root { --bg:#fdf6e3; --card:#f9f2dd; --ink:#2b1a08; --muted:#7c6a4c; --accent:#8b4513; --ok:#1f7a1f; --bad:#8b1a1a; --tag:#5a3816; --link:#174ea6; }
    html, body { margin:0; padding:0; min-height:100%; box-sizing:border-box; background: var(--bg); color:var(--ink); font:16px/1.5 "Book Antiqua", Palatino, serif; }
    header { text-align:center; padding: 12px 10px 0 10px; }
    header h1 { margin:8px 0 0 0; }
    header .sub { color: var(--muted); }
    .wrap { padding:0 16px; }
    .panel { background:#f9f2dd; border:2px solid #c8a96c; border-radius:16px; padding:14px; margin:12px auto; max-width:1100px; }

    .controls { display:flex; flex-direction:column; gap:10px; }
    .row { display:flex; align-items:center; gap:10px; flex-wrap:wrap; }
    .pill { background:#fff9e6; border:1px solid #c8a96c; border-radius:999px; padding:10px 12px; display:flex; align-items:center; gap:8px; flex-wrap:wrap; }

    input[type="range"] { -webkit-appearance:none !important; appearance:none !important; width:260px; height:10px; border-radius:5px; background:linear-gradient(to right, #d6b87a, #b38b4d); outline:none; margin:0 8px; cursor:pointer; border:1px solid #8b5a2b; box-shadow:inset 0 0 4px rgba(0,0,0,.4); }
    input[type="range"]::-webkit-slider-thumb { -webkit-appearance:none !important; appearance:none !important; width:20px; height:20px; border-radius:50%; background:radial-gradient(circle at 30% 30%, #d6b87a, #8b5a2b); border:2px solid #5c3b16; box-shadow:inset 0 0 6px #d6b87a, 0 0 2px #000; cursor:pointer; transition:transform .05s ease-in-out; }
    input[type="range"]:active::-webkit-slider-thumb { transform:scale(1.05); }
    #thresholdNumber { width:90px; background:#fff9e6; color:#2b1a08; border:2px solid #c8a96c; border-radius:8px; padding:6px 8px; font-family:'Book Antiqua', Palatino, serif; box-shadow:inset 0 0 5px #d6b87a; }

    .btn { background:#fff9e6; border:1px solid #c8a96c; border-radius:10px; padding:6px 10px; cursor:pointer; }
    .btn-mini { padding:4px 8px; font-size:13px; }

    .table-wrap { overflow-x:auto; -webkit-overflow-scrolling:touch; }
    table { width:100%; border-collapse: collapse; }
    thead th { background:#f2e6c6; color:#3a240a; border-bottom:2px solid #d6b87a; padding:8px; text-align:left; }
    tbody td { border-top:1px solid #e4cf9e; padding:8px; }
    tbody tr:nth-child(even) { background:#fbf2de; }
    tbody tr:nth-child(odd)  { background:#f6ebd2; }

    .small { font-size:13px; color:#5a3816; }
    .tag { display:inline-block; padding:2px 6px; border-radius:999px; border:1px solid #c8a96c; background:#fff9e6; margin-left:6px; font-size:12px; color:var(--tag); }
    .tag.banned { border-color:#b66; background:#fde9e9; color:var(--bad); }
    .tag.restricted { border-color:#b88; background:#fbeff8; }

    .kpi { font-weight:700; }
    .meter { height:12px; background:#eadfbe; border:1px solid #c8a96c; border-radius:999px; overflow:hidden; }
    .meter > div { height:100%; background:linear-gradient(90deg,#6bcb6b,#ffd166,#ff9248,#ef476f); width:0%; }

    .score-hero { display:flex; align-items:center; gap:16px; flex-wrap:wrap; }
    .score-badge { background:#f2e6c6; border:1px solid #c8a96c; padding:10px 14px; border-radius:12px; min-width:260px; }

    .modal { position: fixed; inset: 0; display: none; align-items: center; justify-content: center; background: rgba(0,0,0,0.5); padding: 16px; z-index: 1000; }
    .modal.open { display: flex; }
    .modal-card { max-width: 680px; width: 100%; background: var(--card); border: 2px solid #c8a96c; border-radius: 16px; box-shadow: 0 10px 30px rgba(0,0,0,35); padding: 14px; }
    .modal-head { display:flex; align-items:flex-start; gap: 8px; }
    .modal-title { font-weight: 800; color:#3a240a; font-size:20px; }
    .modal-close { margin-left:auto; cursor: pointer; border: 1px solid #c8a96c; background: #fff9e6; border-radius: 10px; padding: 4px 8px; }
    pre.cardtext { white-space: pre-wrap; font-family: ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, monospace; background: #fff9e6; border: 1px solid #c8a96c; border-radius: 8px; padding: 8px; }

    @media (max-width: 640px) {
      .controls { gap: 8px; }
      .row { flex-direction: column; gap: 8px; max-width:100%; }
      .pill { width:100%; min-width:0; flex-wrap:wrap; }
      .wrap { padding:0 8px; }
      .panel { border-radius: 12px; padding: 12px; }
    }
  </style>
</head>
<body>
  <header>
    <h1>⚡ 4HM Jank‑O‑Meter ⚡</h1>
    <div class="sub">Earlier scoring baseline with neutralized staples & land‑neutral denominator (single‑file build).</div>
  </header>

  <div class="wrap">
    <div class="panel">
      <div class="controls">
        <div class="row">
          <div class="pill" title="Threshold = maximum lifetime 4HM Total to include">
            <span>Threshold ≤ <span id="thresholdLabel" class="kpi">…</span></span>
            <input id="threshold" type="range" min="0" max="100" value="5" step="1"/>
            <input id="thresholdNumber" type="number" min="0" value="5" step="1" title="Type an exact threshold"/>
          </div>
          <div class="pill" id="quickPresets" title="Quick jank thresholds">
            Quick:
            <button class="btn btn-mini" data-th="1">≤1</button>
            <button class="btn btn-mini" data-th="2">≤2</button>
            <button class="btn btn-mini" data-th="4">≤4</button>
            <button class="btn btn-mini" data-th="10">≤10</button>
            <button class="btn btn-mini" data-th="20">≤20</button>
            <button class="btn btn-mini" data-th="25">≤25</button>
          </div>
        </div>
      </div>

      <div class="table-wrap">
        <table id="jankTable">
          <thead>
            <tr>
              <th>Set</th>
              <th>Card</th>
              <th>Main Deck</th>
              <th>Sideboard</th>
              <th>Total</th>
              <th>Jank Pts (per copy)</th>
            </tr>
          </thead>
          <tbody></tbody>
        </table>
      </div>
      <div class="small" id="meta">Loading data…</div>
    </div>

    <div class="panel" id="scorePanel">
      <h2 style="margin:0 0 10px 0; color:#3a240a;">🧪 Deck Scoring (earlier model, patched)</h2>
      <div class="score-hero">
        <div class="score-badge">
          <div><b>Jank Score</b> <span id="scoreValue" class="kpi">—</span>/100</div>
          <div class="meter" aria-hidden="true"><div id="scoreBar"></div></div>
          <div id="scoreFlavor" class="small">Paste a deck to score it.</div>
        </div>
        <div class="score-badge">
          <div><b>Badges</b></div>
          <div id="badges" class="small">—</div>
        </div>
      </div>
      <div style="margin-top:10px;">
        <label for="deckInput" class="small">Paste your list (sideboard optional):</label>
        <textarea id="deckInput" style="width:100%; min-height:160px; box-sizing:border-box; background:#fff9e6; border:2px solid #c8a96c; border-radius:12px; padding:10px; font-family: ui-monospace, Menlo, Consolas, monospace;" placeholder="e.g.
3 Sword of the Ages
1 Sylvan Library
...

SIDEBOARD:
3 Crumble
..."></textarea>
        <div class="small" style="margin-top:6px;">
          <input type="file" id="deckFile" accept=".txt,.dek,.dec,.mwdeck,.csv,.list"/>
          <button id="analyzeBtn" class="btn">Analyze &amp; Score</button>
          <label style="margin-left:8px;"><input type="checkbox" id="includeSb"/> Include sideboard in scores</label>
        </div>
      </div>
      <div class="score-badge" style="margin-top:10px;">
        <div><b>Top 10 Jankiest in Deck</b></div>
        <ol id="topJank" class="small" style="margin:6px 0 0 18px;"></ol>
      </div>
    </div>
  </div>

  <!-- Card Modal -->
  <div id="cardModal" class="modal" role="dialog" aria-modal="true" aria-labelledby="cardTitle">
    <div class="modal-card">
      <div class="modal-head">
        <div class="modal-title" id="cardTitle">Card</div>
        <button class="modal-close" id="modalClose">Close</button>
      </div>
      <pre id="cardText" class="cardtext"></pre>
    </div>
  </div>

  <script>
    // ======= CONFIG (replace with your live CSVs if needed) =======
    const CARDPOOL_URL = "https://docs.google.com/spreadsheets/d/e/2PACX-1vTbTvT5tNT1w_Nqz1dL-t3muSuqzQ8UkO9ssHNZT1koEM8iVQQuY7QwGpTImtqv58zT837gLm8GZG84/pub?output=csv"; // 4HM usage
    const BR_URL       = "https://docs.google.com/spreadsheets/d/e/2PACX-1vQP2NPEcvsNl4wkBSKApw-opRIZ-C3rwFj51wJbMh1wYm_ci8y7o46gyfSubTbsfApvpoJpS2ysRohD/pub?output=csv"; // ban/restrict overlay

    // ======= GLOBALS =======
    let allRows = [];            // table rows (enriched)
    let dataLoaded = false;
    let MAX_TOTAL = 1;

    let LEGAL_CARDS = new Map(); // key -> raw row
    let NAME_MAP = new Map();
    let BANNED = new Set();
    let RESTRICTED = new Set();

    const BASIC_SET = new Set(["plains","island","swamp","mountain","forest"]);
    const DUELS_SET = new Set(["badlands","bayou","plateau","savannah","scrubland","taiga","tropicalisland","tundra","undergroundsea","volcanicisland"]);
    const OVERPLAYED_THRESHOLD = 350; // staples cutoff

    // ======= UTIL =======
    function normName(s){ return String(s||'').normalize('NFKD').replace(/[\u2018\u2019\u201A\u201B\u2032]/g, "'").replace(/[\u201C\u201D\u201E\u201F\u2033]/g, '"').replace(/[\u2013\u2014]/g, '-').replace(/\[[^\]]*\]/g,'').replace(/\([^)]*\)$/,'').replace(/\s+/g,' ').trim().toLowerCase().replace(/[^a-z0-9]/g,''); }
    function typeHas(t, word){ return new RegExp(`(?:^|,|\\s)${word}(?:,|\\s|$)`, 'i').test(t||''); }
    function isLandKey(key){ const r = LEGAL_CARDS.get(key); return r ? /(^|\s|,)land(,|\s|$)/i.test(String(r.types||r.typesStr)) : false; }
    function logWeightFromTotal(t){ const logMax = Math.log(Math.max(1,MAX_TOTAL)+1); return 100 * (1 - (Math.log((Number(t)||0)+1) / logMax)); }

    function parseCSV(url){ return fetch(url).then(r=>{ if(!r.ok) throw new Error('Network'); return r.text(); }).then(txt=>csvToRows(txt)); }
    function csvToRows(text){
      const [head, ...lines] = text.split(/\r?\n/).filter(Boolean);
      const headers = head.split(',').map(h=>h.trim());
      return lines.map(line=>{
        const cols = splitCSVLine(line, headers.length);
        const obj = {}; headers.forEach((h,i)=> obj[h] = cols[i]);
        return obj;
      });
    }
    function splitCSVLine(line, n){
      const out=[]; let cur=''; let q=false; for(let i=0;i<line.length;i++){
        const ch=line[i];
        if(ch==='"'){ if(q && line[i+1]==='"'){ cur+='"'; i++; } else { q=!q; } }
        else if(ch===',' && !q){ out.push(cur); cur=''; }
        else cur+=ch;
      }
      out.push(cur);
      while(out.length<n) out.push('');
      return out.map(s=>s.trim());
    }

    // ======= BOOT =======
    window.addEventListener('DOMContentLoaded', boot);
    async function boot(){
      try{
        const [pool, br] = await Promise.all([ parseCSV(CARDPOOL_URL), parseCSV(BR_URL) ]);
        ingestPool(pool); ingestBR(br); dataLoaded = true; initUI();
        document.getElementById('meta').textContent = `Loaded ${allRows.length.toLocaleString()} rows • Max Total = ${Math.max(1,MAX_TOTAL).toLocaleString()}`;
      }catch(e){ document.getElementById('meta').textContent = 'Data load issue — refresh?' }
    }

    function ingestPool(rows){
      if(!rows?.length) return;
      const headers = Object.keys(rows[0]||{});
      const nameKey  = headers.find(h => /^name$/i.test(h)) || headers[0];
      const setKey   = headers.find(h => /^set$/i.test(h));
      const mainKey  = headers.find(h => /4hm\s*main(deck)?/i.test(h)) || '4hmMainDeck';
      const sideKey  = headers.find(h => /4hm\s*side(board)?/i.test(h)) || '4hmSideBoard';
      const totalKey = headers.find(h => /4hm\s*total/i.test(h)) || '4hmTotal';
      const textKey  = headers.find(h => /text|oracle|rules/i.test(h)) || 'text';
      const mvKey    = headers.find(h => /mana.?value|cmc/i.test(h)) || 'manaValue';

      const toNum = v => { const n = Number(String(v||'').replace(/,/g,'')); return isFinite(n) ? n : 0; };

      for(const r of rows){
        const rawName = r[nameKey]; if(!rawName) continue; const key = normName(rawName);
        const set = String(setKey ? r[setKey] : '').trim();
        const main = toNum(r[mainKey]); const side = toNum(r[sideKey]); const tot = toNum(r[totalKey]);
        const text = String(r[textKey]||'').trim();
        const manaCost = String(r.manaCost||r["mana cost"]||r.cost||'').trim();
        const mv = Number(r[mvKey]||0);
        const typesStr = String(r.types||'').toLowerCase();
        const supersStr = String(r.supertypes||'').toLowerCase();

        NAME_MAP.set(key, String(rawName));
        const raw = { ...r, key, card:String(rawName), set, main, side, total:tot, text, manaCost, manaValue:mv, types:typesStr, supertypes:supersStr };
        LEGAL_CARDS.set(key, raw);
        if(String(r.banned).toLowerCase()==='true') BANNED.add(key);
        if(String(r.restricted).toLowerCase()==='true') RESTRICTED.add(key);
        if(tot>MAX_TOTAL) MAX_TOTAL = tot;

        allRows.push({ set, card:String(rawName), main, side, total:tot, jankValue:0, text, manaCost, mv, key, typesStr, supersStr });
      }
    }

    function ingestBR(rows){
      if(!rows?.length) return;
      const headers = Object.keys(rows[0]||{});
      const nameKey = headers.find(h => /^name$/i.test(h) || /card\s*name/i.test(h) || /^card$/i.test(h)) || headers[0];
      const bannedKey = headers.find(h => /^banned$/i.test(h));
      const restrictedKey = headers.find(h => /^restricted$/i.test(h));
      const truthy = v => { const s = String(v||'').trim().toLowerCase(); return s && s!=='0' && s!=='false' && s!=='no' && s!=='n' && s!=='na'; };
      for(const r of rows){ const key = normName(r[nameKey]); if(!key) continue; if(bannedKey && truthy(r[bannedKey])) BANNED.add(key); if(restrictedKey && truthy(r[restrictedKey])) RESTRICTED.add(key); }
    }

    // ======= UI =======
    function initUI(){
      const slider = document.getElementById('threshold');
      const box = document.getElementById('thresholdNumber');
      const label = document.getElementById('thresholdLabel');

      const initialAbs = 4;
      slider.min='0'; slider.max='100'; slider.value = String(thresholdToSlider(initialAbs));
      box.min='0'; box.value = String(initialAbs);
      label.textContent = Number(initialAbs).toLocaleString();

      const syncFromSlider = (sVal) => { const abs = sliderToThreshold(Number(sVal)); box.value = String(abs); label.textContent = abs.toLocaleString(); renderTable(abs); };
      const syncFromBox = (bVal) => { const abs = Math.max(0, Math.min(Number(bVal)||0, Math.max(1,MAX_TOTAL))); slider.value = String(thresholdToSlider(abs)); label.textContent = abs.toLocaleString(); renderTable(abs); };
      slider.addEventListener('input', e=>syncFromSlider(e.target.value));
      box.addEventListener('input', e=>syncFromBox(e.target.value));
      document.querySelectorAll('#quickPresets .btn-mini').forEach(b=> b.addEventListener('click',()=>{ const abs=Math.min(Number(b.dataset.th), Math.max(1,MAX_TOTAL)); box.value=String(abs); slider.value=String(thresholdToSlider(abs)); label.textContent=abs.toLocaleString(); renderTable(abs); }));

      renderTable(initialAbs);

      // Deck tools
      const ta = document.getElementById('deckInput');
      const file = document.getElementById('deckFile');
      const btn = document.getElementById('analyzeBtn');
      const includeSb = document.getElementById('includeSb');
      file?.addEventListener('change', () => {
        try{
          const f = file.files && file.files[0];
          if(!f) return;
          const finalize = (txt) => { ta.value = String(txt||''); btn.click(); };
          if(f.text && typeof f.text === 'function'){
            f.text().then(finalize).catch(()=>readLegacy());
          } else { readLegacy(); }
          function readLegacy(){ const reader = new FileReader(); reader.onload = () => finalize(reader.result); reader.readAsText(f); }
        }catch(e){ alert('File read failed'); }
      });
      btn.addEventListener('click', () => {
        if(!dataLoaded){ alert('Data still loading'); return; }
        const text = (ta.value||'').trim(); if(!text){ alert('Paste a decklist first.'); return; }
        const parsed = parseDeckSmart(text);
        const report = scoreDeck(parsed, includeSb?.checked);
        renderDeckScore(report);
      });
    }

    function sliderToThreshold(s){ const k = Math.log(Math.max(1,MAX_TOTAL)+1)/100; return Math.round(Math.exp(k*s)-1); }
    function thresholdToSlider(t){ const k = Math.log(Math.max(1,MAX_TOTAL)+1)/100; return Math.round(Math.log((t||0)+1)/(k||1)); }

    function renderTable(threshold){
      const tbody = document.querySelector('#jankTable tbody');
      const rows = allRows.filter(r => r.total <= threshold);
      rows.forEach(r => { r.jankValue = (BASIC_SET.has(r.key) || DUELS_SET.has(r.key) || r.total >= OVERPLAYED_THRESHOLD) ? 0 : Number((logWeightFromTotal(r.total)/60).toFixed(2)); });
      tbody.innerHTML = rows.map(r => `
        <tr>
          <td>${r.set||''}</td>
          <td><a href="#" data-key="${r.key}" class="cardlink">${r.card}</a>${BANNED.has(r.key)?'<span class="tag banned">BANNED</span>':(RESTRICTED.has(r.key)?'<span class="tag restricted">Restricted</span>':'')}</td>
          <td>${r.main}</td>
          <td>${r.side}</td>
          <td>${r.total}</td>
          <td>${r.jankValue.toFixed(2)}</td>
        </tr>`).join('');

      // Bind modal links
      document.querySelectorAll('a.cardlink').forEach(a=>{
        a.addEventListener('click', (e)=>{ e.preventDefault(); const k = a.getAttribute('data-key'); const row = allRows.find(x=>x.key===k); if(!row) return; showCardModal(row); });
      });
    }

    // ======= Modal =======
    function showCardModal(row){
      document.getElementById('cardTitle').textContent = row.card || 'Card';
      document.getElementById('cardText').textContent = (row.text||'').trim() || '(no rules text)';
      document.getElementById('cardModal').classList.add('open');
    }
    document.getElementById('modalClose').addEventListener('click', ()=> document.getElementById('cardModal').classList.remove('open'));
    document.getElementById('cardModal').addEventListener('click', (e)=>{ if(e.target.id==='cardModal') e.currentTarget.classList.remove('open'); });

    // ======= Deck parsing & scoring (earlier model + patches) =======
    function parseDeckSmart(text){
      const lines = String(text||'').split(/\r?\n/);
      const main = new Map(); const side = new Map();
      let toSide = false;
      for(let raw of lines){
        if(raw == null) continue;
        let line = String(raw).trim();
        if(!line || /^\s*\/\//.test(line)) continue;
        if(/^side\s*board\s*:?/i.test(line)){ toSide = true; continue; }
        if(/^main\s*board\s*:?/i.test(line)){ toSide = false; continue; }
        if(/^SB\b\s*:?-?/i.test(line)){ line = line.replace(/^SB\b\s*:?-?\s*/i, ''); toSide = true; }
        line = line.replace(/\[[^\]]+\]/g,'').replace(/\([^\)]*\)$/,'').trim();
        if(!line) continue;
        let count = 1, name = line; const m = line.match(/^(\d+)\s+(.+)$/); if(m){ count = parseInt(m[1],10); name = m[2]; }
        const key = normName(name); if(!key || key==='mainboard') continue;
        const bucket = toSide ? side : main; bucket.set(key, (bucket.get(key)||0) + (isFinite(count)?count:1));
      }
      return {main, side};
    }

    function scoreDeck(parsed, includeSide){
      const toRow = new Map(); const nameMap = new Map();
      for(const r of allRows){ const k = normName(r.card); if(!nameMap.has(k)) nameMap.set(k, r.card); if(!toRow.has(k)) toRow.set(k, r); }
      function mapToArr(m){ return Array.from(m.entries()).map(([key,count])=>({key, count})); }
      const matchedMain = mapToArr(parsed.main).map(it=>({ ...it, total: Number((toRow.get(it.key)||{}).total)||0, official: nameMap.get(it.key)||it.key }));
      const matchedSide = mapToArr(parsed.side).map(it=>({ ...it, total: Number((toRow.get(it.key)||{}).total)||0, official: nameMap.get(it.key)||it.key }));

      const weight = (t) => logWeightFromTotal(t);
      let copiesMain = 0, raw = 0;
      for (const m of matchedMain){
        copiesMain += m.count;
        const w = ((BASIC_SET.has(m.key) || DUELS_SET.has(m.key) || m.total >= OVERPLAYED_THRESHOLD)) ? 0 : weight(m.total);
        raw += m.count * w;
      }
      let rawSide = 0; if (includeSide){ for (const s of matchedSide){ const w = ((BASIC_SET.has(s.key) || DUELS_SET.has(s.key) || s.total >= OVERPLAYED_THRESHOLD)) ? 0 : weight(s.total); rawSide += s.count * w; }}

      // Land‑neutral denominator: ONLY main non‑land copies define the scale
      const nonLandMain = matchedMain.reduce((a,m)=> a + (isLandKey(m.key)?0:m.count), 0);
      const deepCopies = matchedMain.filter(x => x.total <= 20).reduce((a,b)=> a + b.count, 0); // earlier model used ≤20 for density
      const deepDensity = copiesMain ? Math.round(100 * deepCopies / copiesMain) : 0; // earlier model counted all main copies
      const rawMax = Math.max(1, nonLandMain) * 100; // patched from fixed 60*100 → scale to non‑land main

      const baseScore = Math.max(0, Math.min(100, ((raw + (includeSide ? rawSide : 0)) / rawMax) * 100));
      const bonus = Math.round(25 * Math.pow(deepDensity / 100, 1.1)); // keep earlier density curve
      const over60 = Math.max(0, copiesMain - 60);
      const over60Bonus = over60 * 0.25; // earlier model kept this

      const finalScore = Math.max(0, Math.min(100, baseScore + bonus + over60Bonus));

      // Top jankiest (per‑copy weight), basics/duals/staples=0
      const allForTop = [...matchedMain].map(x => ({key:x.key, name:x.official, w: ((BASIC_SET.has(x.key) || DUELS_SET.has(x.key) || x.total >= OVERPLAYED_THRESHOLD)) ? 0 : weight(x.total), total:x.total, count:x.count}));
      allForTop.sort((a,b)=> b.w - a.w); const top10 = allForTop.slice(0,10);

      return { score: Math.round(finalScore), baseScore: Math.round(baseScore), bonus, copiesMain, deepDensity, over60, over60Bonus, top10 };
    }

    function renderDeckScore(r){
      const scoreEl = document.getElementById('scoreValue'); const bar = document.getElementById('scoreBar'); const flavor = document.getElementById('scoreFlavor'); const badges = document.getElementById('badges'); const top = document.getElementById('topJank');
      scoreEl.textContent = r.score; bar.style.width = r.score + '%';
      let msg = '';
      if (r.score >= 90) msg = '🧪 Maximum spice achieved — expect the unexpected.';
      else if (r.score >= 70) msg = '🌋 The Jank is STRONG with this one.';
      else if (r.score >= 50) msg = '🌶️ Solidly spicy — a connoisseur’s brew.';
      else if (r.score >= 30) msg = '🧯 Respectable heat with room to get weird.';
      else msg = '🛡️ More staple than spice. Dare to jank harder?';
      if (r.bonus >= 15) msg += ' 🧪 Dense spice pocket detected.';
      flavor.textContent = msg;
      badges.innerHTML = `
        <div>📈 <b>Jank Density:</b> ${r.deepDensity}% of maindeck</div>
        <div>➕ <b>Density bonus added:</b> +${r.bonus} (max +25)</div>
        <div>🧾 <b>Counted copies (main):</b> ${r.copiesMain}</div>
        <div>📦 <b>Cards above 60:</b> ${r.over60} (+${r.over60Bonus.toFixed(2)})</div>`;
      top.innerHTML = '';
      for (const t of r.top10){ const li = document.createElement('li'); li.innerHTML = `${t.name} <span class="small">(${(t.w/60).toFixed(2)} pts/copy)</span>`; top.appendChild(li); }
    }
  </script>
</body>
</html>
